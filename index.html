<!DOCTYPE html>
<html>
	<head>
	<title>ASCII Design</title>
<style>
* { margin:0; padding:0; } /* to remove the top and left whitespace */

html, body { width:100%; height:100%; } /* just to be sure these are full screen*/

canvas { 
    position: fixed;
    top: 0;
    left: 0;
    display:block; 
}
</style>
	<script>
let ctx;
let canvas;
let fontHeight = 40;
let fontFamily = "Monospace";
let charSize;
let padding = { x:0, y:0 }
let objects = []
let cursor = { row:-1, col:-1}

var grayscale_characters = ['\u2588', '\u2593', '\u2592', '\u2591', ' ']

const NONE     = 0;
const UP       = 1;
const TOP      = 1;
const DOWN     = 2;
const BOTTOM   = 2;
const VERTICAL = UP + DOWN;


const LEFT       = 4;
const RIGHT      = 8;
const HORIZONTAL = LEFT + RIGHT;

const UP_LEFT      = UP     + LEFT;
const UP_RIGHT     = UP     + RIGHT;
const DOWN_LEFT    = DOWN   + LEFT;
const DOWN_RIGHT   = DOWN   + RIGHT
const TOP_LEFT     = TOP    + LEFT;
const TOP_RIGHT    = TOP    + RIGHT;
const BOTTOM_LEFT  = BOTTOM + LEFT;
const BOTTOM_RIGHT = BOTTOM + RIGHT


// Box styles characters
const BOX_LEFT=0;
const BOX_RIGHT=1;
const BOX_TOP=2;
const BOX_BOTTOM=3;
const BOX_UPPER_LEFT=4;
const BOX_UPPER_RIGHT=5;
const BOX_LOWER_LEFT=6;
const BOX_LOWER_RIGHT=7;

const boxStyle = {
    ascii:  "||--++++",
    box:    "││──┌┐└┘",
    hash:   "########",
    matrix: "││  ┌┐└┘",
    block:  "████████"
}



class Box {
    constructor(row, col, width, height, style) {
        this.style = style;
        this.row = row;
        this.col = col;
        this.width = width;
        this.height = height;
    }

    draw() {
        drawChar(this.style[BOX_UPPER_LEFT] , this.row                  , this.col)
        drawChar(this.style[BOX_UPPER_RIGHT], this.row                  , this.col + this.width - 1)
        drawChar(this.style[BOX_LOWER_LEFT] , this.row + this.height - 1, this.col)
        drawChar(this.style[BOX_LOWER_RIGHT], this.row + this.height - 1, this.col + this.width - 1)
        for(let c=1; c<this.width-1; c++) {
            drawChar(this.style[BOX_TOP]   , this.row                  , this.col + c);
            drawChar(this.style[BOX_BOTTOM], this.row + this.height - 1, this.col + c);
        }
        for(let r=1; r<this.height-1; r++) {
            drawChar(this.style[BOX_LEFT] , this.row + r, this.col);
            drawChar(this.style[BOX_RIGHT], this.row + r, this.col + this.width - 1);
        }
    }
}


class Point {
    constructor(row,col,next,previous) {
        this.row = row;
        this.col = col;
        this.next = next;
        this.previous = previous;
    }

    add(p) {
    	this.next=p;
    	p.previous = this;
    	return p;
	}

	head() {
    	let p = this;
    	while( p.previous ) p = p.previous;
    	return p
	}

	tail() {
    	let p = this;
    	while( p.next ) p = p.next;
    	return p
	}

	corner() {
    	return this.previous.direction(this) + this.next.direction(this);
	}

    /*
    Returns the direction from this point to the next point
     */
    direction(next) {
		if( !next && this.next ) {
			next = this.next;
		}

		let direction = NONE;
		if( next ) {
			if( this.col > next.col ) {
				direction += LEFT;
			} else if ( this.col < next.col ) {
				direction += RIGHT;
			}

			if ( this.row > next.row ) {
				direction += UP;
			} else if ( this.row < next.row ) {
				direction += DOWN;
			}
		}
		return direction;
	}
}

const lineStyle = {}
lineStyle.ascii = {start: {}, line: {}, end: {}, connect: {}};
lineStyle.ascii.start[NONE]           = "+";
lineStyle.ascii.start[UP]             = "|";
lineStyle.ascii.start[DOWN]           = "|";
lineStyle.ascii.start[LEFT]           = "-";
lineStyle.ascii.start[RIGHT]          = "-";
lineStyle.ascii.line[UP]              = "|";
lineStyle.ascii.line[DOWN]            = "|";
lineStyle.ascii.line[LEFT]            = "-";
lineStyle.ascii.line[RIGHT]           = "-";
lineStyle.ascii.end[UP]               = "|";
lineStyle.ascii.end[DOWN]             = "|";
lineStyle.ascii.end[LEFT]             = "-";
lineStyle.ascii.end[RIGHT]            = "-";
lineStyle.ascii.connect[TOP_LEFT]     = "+";
lineStyle.ascii.connect[TOP_RIGHT]    = "+";
lineStyle.ascii.connect[BOTTOM_RIGHT] = "+";
lineStyle.ascii.connect[BOTTOM_LEFT]  = "+";
lineStyle.ascii_round = {start: {}, line: {}, end: {}, connect: {}};
lineStyle.ascii_round.start[UP]             = "|";
lineStyle.ascii_round.start[DOWN]           = "|";
lineStyle.ascii_round.start[LEFT]           = "-";
lineStyle.ascii_round.start[RIGHT]          = "-";
lineStyle.ascii_round.line[UP]              = "|";
lineStyle.ascii_round.line[DOWN]            = "|";
lineStyle.ascii_round.line[LEFT]            = "-";
lineStyle.ascii_round.line[RIGHT]           = "-";
lineStyle.ascii_round.end[UP]               = "|";
lineStyle.ascii_round.end[DOWN]             = "|";
lineStyle.ascii_round.end[LEFT]             = "-";
lineStyle.ascii_round.end[RIGHT]            = "-";
lineStyle.ascii_round.connect[TOP_LEFT]     = "/";
lineStyle.ascii_round.connect[TOP_RIGHT]    = "\\";
lineStyle.ascii_round.connect[BOTTOM_RIGHT] = "/";
lineStyle.ascii_round.connect[BOTTOM_LEFT]  = "\\";
lineStyle.box = {start: {}, line: {}, end: {}, connect: {}};
lineStyle.box.start[UP]             = "┴";
lineStyle.box.start[DOWN]           = "┬";
lineStyle.box.start[LEFT]           = "┤";
lineStyle.box.start[RIGHT]          = "├";
lineStyle.box.line[UP]              = "│";
lineStyle.box.line[DOWN]            = "│";
lineStyle.box.line[LEFT]            = "─";
lineStyle.box.line[RIGHT]           = "─";
lineStyle.box.end[UP]               = "┴";
lineStyle.box.end[DOWN]             = "┬";
lineStyle.box.end[LEFT]             = "┤";
lineStyle.box.end[RIGHT]            = "├";
lineStyle.box.connect[TOP_LEFT]     = "┌";
lineStyle.box.connect[TOP_RIGHT]    = "┐";
lineStyle.box.connect[BOTTOM_RIGHT] = "┘";
lineStyle.box.connect[BOTTOM_LEFT]  = "└";
lineStyle.block = {start: {}, line: {}, end: {}, connect: {}};
lineStyle.block.start[UP]             = "█";
lineStyle.block.start[DOWN]           = "█";
lineStyle.block.start[LEFT]           = "█";
lineStyle.block.start[RIGHT]          = "█";
lineStyle.block.line[UP]              = "█";
lineStyle.block.line[DOWN]            = "█";
lineStyle.block.line[LEFT]            = "█";
lineStyle.block.line[RIGHT]           = "█";
lineStyle.block.end[UP]               = "█";
lineStyle.block.end[DOWN]             = "█";
lineStyle.block.end[LEFT]             = "█";
lineStyle.block.end[RIGHT]            = "█";
lineStyle.block.connect[TOP_LEFT]     = "█";
lineStyle.block.connect[TOP_RIGHT]    = "█";
lineStyle.block.connect[BOTTOM_RIGHT] = "█";
lineStyle.block.connect[BOTTOM_LEFT]  = "█";

const moveFunction = {};
moveFunction[NONE] = p => false;
moveFunction[UP] = p => p.row--;
moveFunction[DOWN]  = p => p.row++;
moveFunction[LEFT]  = p => p.col--;
moveFunction[RIGHT] = p => p.col++;

class Line {
    constructor(start, style) {
    	this.start = start;
		this.style = style;
    }

    draw() {
		const style = this.style;
		let p = this.start;
		const drawLine = {};

		while( p ) {
			drawLine.direction = p.direction();
			if( drawLine.direction ) {
				drawLine.move = moveFunction[drawLine.direction];
				drawLine.row = p.row;
				drawLine.col = p.col;
				if( p.next ) {
					if( p.previous ) {
						drawChar(style.connect[p.corner()],p.row,p.col)
					} else {
						drawChar(style.start[drawLine.direction] , p.row , p.col);
					}
					drawLine.next = function() {
						drawChar(style.line[this.direction],this.row,this.col);
						this.move(this);
						return this.col != p.next.col || this.row != p.next.row;
					};
					drawLine.move(drawLine);
				} else {
					drawChar(style.end[p.direction(p.previous)],p.row,p.col)
					drawLine.next = function() { return false; }
				}

				while( drawLine.next() ) {}
			}
    		p = p.next;
		}
	}
}

class Text {
	constructor(text, row, col, style, backgroundStyle) {
		this.text = text;
		this.row = row;
		this.col = col;
		this.style = style;
		this.backgroundStyle = backgroundStyle;
	}

	draw() {
		drawChar(this.text, this.row, this.col, this.style, this.backgroundStyle);
	}
}

function calculateCharacterSize() {
    const bufferCanvas = document.createElement("canvas");
    bufferCanvas.width = 3*fontHeight;
    bufferCanvas.height = 3*fontHeight;
    const bufferContext = bufferCanvas.getContext('2d');

    bufferContext.font = fontHeight+'px '+fontFamily;
    console.log(`font = ${bufferContext.font}`);
    bufferContext.fillStyle = 'red';
    bufferContext.textBaseline = 'top';

    const width = Math.ceil(bufferContext.measureText('█').width);
    console.log(`width = ${width}`);
    console.log(`top = ${fontHeight}`);
    bufferContext.fillText('█', 0, fontHeight);
    //bufferContext.fillRect(0,fontHeight,width,fontHeight);

    let imageData = bufferContext.getImageData(Math.floor(width/2), 0, 1, fontHeight*3);
    let boundingTop = -1;
    let boundingBottom = -1;

    for(let n=0; n<fontHeight*3*4; n+=4) {
        if(imageData.data[n]!=0) {
            boundingTop = n/4;
            console.log(`n = ${n}`);
            break;
        }
    }
    console.log(`boundingTop = ${boundingTop}`);

    console.log(`n = ${4*(boundingTop+1)}`);
    for(n=4*(boundingTop+1); n<fontHeight*3*4; n+=4) {
        if(imageData.data[n]==0) {
            boundingBottom = n/4;
            break;
        }
    }
    console.log(`boundingBottom = ${boundingBottom}`);
    height = boundingBottom - boundingTop;

    charSize = {
        height: height,
        width: width,
        leading: fontHeight - boundingTop 
    };
    console.log(charSize);
    return charSize;
}

function resizeCanvas(e) {
    let dpi = window.devicePixelRatio;
    const height = window.innerHeight;
    canvas.style.height = height+'px';
    canvas.height=height*dpi;
    const width = window.innerWidth
    canvas.style.width = width+'px';
    canvas.width=width*dpi;
    calculateCharacterSize();
    redraw();
}

function col2x(col) {
    return (charSize.width+2*padding.x)*col+padding.x+1;
}

function x2col(x) {
    return Math.floor((x-1-padding.x)/(charSize.width+2*padding.x))
}

function row2y(row) {
    return (charSize.height+2*padding.y)*row+padding.y+1;
}

function y2row(y) {
    return Math.floor((y-1-padding.y)/(charSize.height+2*padding.y))
}

function drawCursor() {
    if( cursor.row>=0 && cursor.col>=0 ) {
        // ctx.fillStyle = 'rgba(0,0,0,.5)';
        // ctx.fillRect(col2x(cursor.col), row2y(cursor.row), charSize.width, charSize.height);
    }
}

function drawGrid() {
    ctx.beginPath();
    for(let x=1; x<canvas.width;  x += (2*padding.x + charSize.width)) {
        ctx.moveTo(x,1);
        ctx.lineTo(x,canvas.height);
    }
    for(let y=1; y<canvas.height; y += (2*padding.y + charSize.height)) {
        ctx.moveTo(1,y);
        ctx.lineTo(canvas.width,y);
    }
    ctx.strokeStyle = '#ccffff';
    ctx.lineWidth = 2;
    ctx.stroke();
}

function drawString(s,row,col) {

}

function drawChar(c, row0, col0, style, backgroundStyle) {
	let col = col0;
	let row = row0;
	for( let i=0; i<c.length; i++ ) {
		if( c[i] == "\n" ) {
			row++;
			col = col0;
			continue;
		}
		const x = col2x(col);
		const y = row2y(row);
		ctx.fillStyle = backgroundStyle || 'white';
		ctx.fillRect(x, y, charSize.width, charSize.height);
		ctx.fillStyle = style || 'black';
		ctx.font = fontHeight+'px '+fontFamily;
		ctx.textBaseline = 'top';
		ctx.fillText(c[i], x, y + charSize.leading);
		col++;
	}
}

function drawObjects() {
    for( let i = 0; i<objects.length; i++ ) {
        objects[i].draw();
    }
}

const logEventHandler = {
	cursorDown:  (row,col) => console.log(`cursorDown(${row},${col})`),
	cursorUp:    (row,col) => console.log(`cursorUp(${row},${col})`),
	cursorClick: (row,col) => console.log(`cursorClick(${row},${col})`),
	cursorMove:  (row,col) => console.log(`cursorMove(${row},${col})`)
}

class LineDrawer {
	straightLine(row,col) {
		const tail = this.line.start.tail().previous;
		const deltaR = Math.abs(tail.row - row);
		const deltaC = Math.abs(tail.col - col);
		if (deltaR > deltaC) {
			col = tail.col;
		} else {
			row = tail.row;
		}
		return [row,col];
	}

	cursorClick(row, col) {
		if( this.line ) {
			[row,col] = this.straightLine(row,col);
			console.log(`new Point(${row},${col}`);
			this.line.start.tail().add(new Point(row,col));
		} else {
			console.log('start Line')
			this.line = new Line((new Point(row,col)).add(new Point(row,col)).head(),lineStyle.ascii);
		}
		this.line.draw();
	}

	cursorMove(row, col) {
		if( this.line ) {
			const tail = this.line.start.tail();
			[row,col] = this.straightLine(row,col);
			tail.row = row;
			tail.col = col;
			redraw();
			this.line.draw();
		}
	}
}

class BoxDrawer {

	cursorDown(row, col) {
		this.box = new Box(row,col,1,1,boxStyle.ascii);
		this.box.draw();
	}

	cursorMove(row, col) {
		if( this.box ) {
			this.box.height = 1 + row - this.box.row;
			this.box.width  = 1 + col - this.box.col;
			redraw();
			this.box.draw();
		}
	}

	cursorUp(row,col) {
		if( this.box ) {
			this.box.height = 1 + row - this.box.row;
			this.box.width  = 1 + col - this.box.col;
			redraw();
			this.box.draw();
			objects.push(this.box);
		}
		this.box = null;
	}
}

lineEventHandler = new LineDrawer();
boxEventHandler = new BoxDrawer();
eventHandler = logEventHandler;

function cursorMove(row,col) {
	if( eventHandler && eventHandler.cursorMove ) {
		eventHandler.cursorMove(row,col);
	}
}

function cursorDown(row,col) {
	if( eventHandler && eventHandler.cursorDown ) {
		eventHandler.cursorDown(row,col);
	}
}

function cursorUp(row,col) {
	if( eventHandler && eventHandler.cursorUp ) {
		eventHandler.cursorUp(row,col);
	}
}

function cursorClick(row,col) {
	if( eventHandler && eventHandler.cursorClick ) {
		eventHandler.cursorClick(row,col);
	}
}

function mouseOut(e) {
	cursor = { row:-1, col:-1}
}

function mouseMove(e) {
    let col = x2col(e.clientX*window.devicePixelRatio);
    let row = y2row(e.clientY*window.devicePixelRatio);
	if( cursor.row != row || cursor.col !=col ) {
		cursor.row = row;
		cursor.col = col;

		cursorMove(row,col);
    }
}

function mouseDown(e) {
	console.log("mousedown");
	e.preventDefault();
	let col = x2col(e.clientX*window.devicePixelRatio);
	let row = y2row(e.clientY*window.devicePixelRatio);
	cursorDown(row,col);
}
function mouseUp(e) {
	console.log("mouseup");
	e.preventDefault();
	let col = x2col(e.clientX*window.devicePixelRatio);
	let row = y2row(e.clientY*window.devicePixelRatio);
	cursorUp(row,col);
}

function click(e) {
	console.log("click");
	e.preventDefault();
	let col = x2col(e.clientX*window.devicePixelRatio);
	let row = y2row(e.clientY*window.devicePixelRatio);
	cursorClick(row,col);
}

function touchStart(e) {
	console.log("touchstart");
	e.preventDefault();
	let col = x2col(e.touches[0].clientX*window.devicePixelRatio);
	let row = y2row(e.touches[0].clientY*window.devicePixelRatio);
	cursorDown(row,col);
}

function touchEnd(e) {
	console.log("touchend");
	e.preventDefault();
	let col = x2col(e.changedTouches[0].clientX*window.devicePixelRatio);
	let row = y2row(e.changedTouches[0].clientY*window.devicePixelRatio);
	cursorUp(row,col);
}


function redraw() {
	canvas.width = canvas.width;
    drawGrid();
    drawObjects();
}

function updateEvent(e) {
    var rect = e.target.getBoundingClientRect();
    e.canvasX = (e.clientX - rect.left)*window.devicePixelRatio;
    e.canvasY = (e.clientY - rect.top )*window.devicePixelRatio;
    return { x, y };
}

function init() {
	canvas = document.getElementById('canvas');
    canvas.addEventListener('mousemove',mouseMove);
    canvas.addEventListener('mouseout',mouseOut);
	canvas.addEventListener('click',click);
	canvas.addEventListener('mousedown',mouseDown);
	canvas.addEventListener('mouseup',mouseUp);
	canvas.addEventListener('touchstart',touchStart);
	canvas.addEventListener('touchend',touchEnd);

	ctx = canvas.getContext('2d');
    window.addEventListener('resize',resizeCanvas);
    resizeCanvas();
}


window.addEventListener('DOMContentLoaded',init);
	</script>
	</head>
	<body>
<!--
<pre>
This is the menu &#x2588;
This the second line
</pre>
    -->
<canvas id="canvas" width="150" height="150"></canvas>
	</body>
</html> 
